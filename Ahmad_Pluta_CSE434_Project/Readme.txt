CSE434: Computer Networks Project 3
By: Rizwan Ahmad and Stephen Pluta


== COMPILATION INSTRUCTIONS == 

A makefile is provided, which can be used to compile the program. To use it, type "make clean" and "make" into a bash terminal. This will create two executables, "client.out" and "server.out" which can be used to run the client and server.

If the makefile fails, the following commands will compile the program as well: "gcc udpClient.c -o client.out" followed by "gcc udpServer.c -o server.out"


== DESCRIPTION == 

In this project, a client and a server are modeled, with the client sending randomly generated characters to the server, and the server maintaining a string containing the last five received characters and returning this string to the client. The client is implemented in udpClient.c, and makes reference to a text file called inc.txt, which contains the incarnation number of the client (initialized to 0). The server, on the other hand, is implemented in udpServer.c.

In the client, there are a few things that happen. First, inc.txt is created and a 0 is written to it. After this, the IP of the current machine is retrieved by utilizing the gethostname() and getaddrinfo() functions. A socket with a timeout interval of 3 seconds, which will be used to communicate with the server, is then constructed. The program will then drop into a loop which sends 20 packets, in the form of a request struct, to the server. To do this, the struct is first populated with the client's IP, incarnation number, client number, and a random character. This struct is then sent to the server, and the client awaits a response. If the timeout is reached, the client will send the struct again, until the response is received. The client then prints out the data it receives, and iterates through the loop again until it has gone through 20 times.

While the loop is iterating, another integer, k, is used to simulate failures of the client. This is accomplished by initializing k to a random integer from 1 to 20. When the loop iterates k times, the loop will drop into a special if statement which determines whether or not a failure should be simulated. To do this, k is set to a new randomized number. If this new value of k is an even integer, then a failure is simulated and the value of the incarnation number (stored in inc.txt) is incremented. The loop then continues iterating until it reaches the new value of k (although it is possible that it will not reach k a second time), and repeats this process.

The server is a bit less complicated than the client. To initialize the server, an empty string of size 5 is created, and the socket is initialized and bound to the local address. At this point, the server drops into an infinite loop, where it will continuously receive and process requests. In any given iteration of this loop, the first thing that happens is deciding on whether or not the server will simulate a failure with the next received request. To do this, a random number from 0 to 9 is generated. If the number is an 8, then the server will drop the request, and if the number is a 9, the server will process the request but not send a response to the client. In any other case, the server will continue normal operation. In this case, the server will first traverse the client table (discussed below) to see if a request has ever been received from this particular client before. If it has not, then the server adds the client to the client table, modifies the stored string accordingly, and sends the string to the client. If the server has processed requests from this client before, it then compares the current request's request number (R) to the request number of the last received request from that client (r). If R < r, then the current request is ignored and no response is sent. If R = r, then the unmodified string is sent to the client. If R > r, then the string is modified, the client table is updated to reflect the current request, and the response is sent back to the client. Upon processing the request, the server will then return to the beginning of the loop, and wait for the next request to come in.

To implement the client table, a struct which stored IP addresses, incarnation numbers, client numbers, and request numbers was created. An array of these "client" structures was then initialized, and was used as the client table. By utilizing client structures, it was very easy to ensure that a request was indeed from a client that had sent a request before. This also made comparing request numbers very feasible, since these numbers were stored in the client structure itself. Additionally, to facilitate searching of this table, a separate variable, tableSize, was created to keep track of the number of clients stored in the client table. By doing this, traversing through empty portions of the client table was prevented.